<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCola CND Demo</title>
    
    <!-- Bootstrap CSS for component styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <style>
        body {
            display: flex;
            flex-direction: column;
            font-family: Arial, sans-serif;
            max-width: 90vw;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            gap: 20px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .hero {
            background: linear-gradient(135deg, #002d72 0%, #006dbe 60%, #00a0e9 100%);
            color: #fff;
            padding: 24px 28px;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.18);
        }
        .hero h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        .hero .badge {
            background: rgba(255, 255, 255, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.35);
        }
        .onboarding-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 14px;
        }
        .onboarding-card {
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 14px 16px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }
        .onboarding-card h5 {
            margin-bottom: 8px;
            font-size: 1rem;
        }
        #graph-container-wrapper {
            position: relative;
            width: 100%;
            height: 600px;
            margin: 20px 0;
        }
        #graph-container {
            width: 100%;
            height: 600px;
            border: 2px solid #007acc;
            border-radius: 8px;
            display: block; /* Why? Because it's an inline SVG by default */
        }
        #graph-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover {
            background-color: #005a9e;
        }
        #clearGraphButton {
            background-color: red;
        }
        #clearGraphButton:hover {
            background-color: rgb(200, 34, 34);
        }
        #applyLayoutButton {
            font-size: 16px;
        }
        #applyLayoutButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        textarea {
            width: 100%;
            height: 200px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            box-sizing: border-box;
        }
        label {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .status.info { background: #e3f2fd; color: #1976d2; }
        .status.success { background: #e8f5e8; color: #2e7d32; }
        .status.error { background: #ffebee; color: #c62828; }

        /** TODO: Add support for smaller screen sizes */
        /**
         * Responsive design for smaller screens
         * Following modern browser compatibility guidelines
         */
        @media (max-width: 768px) {
            #graph-controls {
                top: 5px;
                right: 5px;
                padding: 6px 8px;
                gap: 6px;
            }
            
            #graph-controls #clearGraphButton {
                padding: 4px 8px;
                font-size: 12px;
            }
            
            #graph-controls #layoutFormat {
                padding: 4px 6px;
                font-size: 12px;
                min-width: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="hero mb-2">
        <div class="d-flex justify-content-between align-items-start flex-wrap gap-2">
            <div>
                <h1 class="h2 mb-1">Spytial onboarding hub</h1>
                <p class="mb-2">Learn the end-to-end Alloy â†’ Spytial â†’ WebCola workflow and ship your first visualization.</p>
                <span class="badge rounded-pill">Guided sample included</span>
            </div>
            <div class="text-end">
                <p class="mb-1 fw-bold">Fast start</p>
                <ol class="mb-0 ps-3 small">
                    <li>Load the guided sample.</li>
                    <li>Press <strong>Apply Layout</strong>.</li>
                    <li>Inspect the graph + YAML.</li>
                    <li>Iterate on your own data.</li>
                </ol>
            </div>
        </div>
    </div>

    <div class="container border" id="main-panel">
        <h1>ðŸŽ¯ Alloy â†’ Spytial â†’ WebCola demo</h1>
        <p class="mb-1">This page is the gh-pages template for onboarding new contributors and users. It walks through the complete pipeline and gives you a safe sandbox for experimentation.</p>
        <p class="text-muted small mb-3">Use the guided sample below if you are new, or paste your own Alloy XML and CND YAML to explore custom layouts.</p>
        <div class="onboarding-grid mb-3">
            <div class="onboarding-card">
                <h5 class="mb-1">1) Understand the flow</h5>
                <p class="mb-0 small">Alloy XML âžœ <code>AlloyDataInstance</code> âžœ <code>ForgeEvaluator</code> âžœ <code>LayoutInstance</code> âžœ WebCola rendering.</p>
            </div>
            <div class="onboarding-card">
                <h5 class="mb-1">2) Try the guided sample</h5>
                <p class="mb-0 small">Preloaded Alloy + CND YAML showcase a binary tree layout with directives and orientation constraints.</p>
            </div>
            <div class="onboarding-card">
                <h5 class="mb-1">3) Tweak + rerender</h5>
                <p class="mb-0 small">Edit YAML in the CND interface, adjust layout format, and re-run <strong>Apply Layout</strong> to see changes.</p>
            </div>
            <div class="onboarding-card">
                <h5 class="mb-1">4) Graduate to real data</h5>
                <p class="mb-0 small">Swap in your Alloy XML and bring your own directives. Use the REPL to validate constraints before rendering.</p>
            </div>
        </div>
        <div class="alert alert-primary" role="alert">
            ðŸš€ First time here? Click <strong>Load guided sample</strong> to prefill the Alloy XML and CND YAML, then hit <strong>Apply Layout</strong>.
        </div>
        <div>
            <!-- Editable Input Fields -->
            <div>
                <label for="webcola-alloy">Alloy XML Instance:</label>
                <textarea id="webcola-alloy" placeholder="Paste your Alloy XML instance here..."></textarea>
            </div>
            <div id="evaluator-repl-mount"></div>
            <div id="status" class="status info">Ready to load Alloy graph...</div>
            <div id="error-messages"></div>
            <div id="relation-highlighter-mount"></div>
            <div id="graph-container-wrapper">
                <div id="graph-controls">
                    <select title="Choose the Layout Format" class="form-select form-select-sm" id="layoutFormat" name="layoutFormat" onchange="changeLayoutFormat()" aria-label="Layout format selection">
                        <option value="default" selected>Standard</option>
                        <option value="grid">Grid (Beta)</option>
                    </select>
                    <button id="clearGraphButton" onclick="clearGraph()" title="Clear the current graph visualization" aria-label="Clear graph">Clear</button>
                </div>
                <!-- Use the webcola-cnd-graph custom element -->
                <webcola-cnd-graph 
                    id="graph-container"
                    width="800" 
                    height="600"
                    layoutFormat="default"
                    aria-label="Interactive graph visualization">
                </webcola-cnd-graph>
            </div>
        </div>
    </div>
    <div id="cnd-panel" class="container d-flex flex-column col-md-4 border p-3">
        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2 mb-2">
            <h5 class="h5 mb-0 text-dark">CND Layout Specification:</h5>
            <div class="d-flex gap-2">
                <button class="btn btn-outline-primary btn-sm" onclick="loadGuidedSample(true)">Load guided sample</button>
                <button class="btn btn-outline-secondary btn-sm" onclick="renderGraph()">Re-render only</button>
            </div>
        </div>
        <button id="applyLayoutButton" class="mb-3" onclick="loadGraph()">Apply Layout</button>
        <div id="webcola-cnd-container">
            <!-- React element attached here -->
        </div>
    </div>

    <div class="container border">
        <h3 class="h5">Onboarding playbook</h3>
        <div class="row g-3">
            <div class="col-md-6">
                <div class="onboarding-card h-100">
                    <h5 class="mb-2">Local development</h5>
                    <ol class="mb-0 small ps-3">
                        <li>Install dependencies: <code>npm install</code>.</li>
                        <li>Build browser bundles: <code>npm run build:browser</code>.</li>
                        <li>Open this page locally: <code>npm run dev</code> and navigate to <code>/webcola-demo/webcola-demo.html</code>.</li>
                        <li>Use <strong>Load guided sample</strong> to validate your toolchain.</li>
                    </ol>
                </div>
            </div>
            <div class="col-md-6">
                <div class="onboarding-card h-100">
                    <h5 class="mb-2">Contribute with confidence</h5>
                    <ul class="mb-0 small ps-3">
                        <li>Use the REPL mount to probe constraints before rendering.</li>
                        <li>Switch layout format (Standard/Grid) to demo different experiences.</li>
                        <li>Share a link to this gh-pages to help others reproduce your steps.</li>
                        <li>When ready, replace the sample Alloy XML with your dataset and iterate.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="container border">
        <h3 class="h5">What this demo actually does</h3>
        <p class="small text-muted mb-2">Here is the exact sequence that runs when you click <strong>Apply Layout</strong>. Use it as a checklist when swapping in other <code>IEvaluator</code> implementations.</p>
        <ol class="small ps-3 mb-0">
            <li><strong>Parse Alloy XML</strong> â†’ <code>AlloyInstance.parseAlloyXML</code> reads your XML and the first instance is wrapped in <code>AlloyDataInstance</code> to provide typed accessors.</li>
            <li><strong>Select an evaluator</strong> â†’ The demo constructs a <code>ForgeEvaluator</code> (an <code>IEvaluator</code>) and initializes it with the Alloy source so it can answer relation queries. Swap in your own <code>IEvaluator</code> here if you need alternative semantics.</li>
            <li><strong>Compile layout spec</strong> â†’ <code>parseLayoutSpec</code> converts the YAML from the CND interface into a <code>LayoutSpec</code> object, surfacing parse errors in the UI if anything is invalid.</li>
            <li><strong>Create a LayoutInstance</strong> â†’ The compiled spec and evaluator are combined into <code>LayoutInstance</code>, which is responsible for producing coordinates and alignment edges from your data.</li>
            <li><strong>Generate a layout</strong> â†’ <code>layoutInstance.generateLayout</code> consumes the <code>AlloyDataInstance</code> and optional projections, returning an <code>InstanceLayout</code>. Constraint conflicts or group overlaps are reported through the modal error helpers.</li>
            <li><strong>Render with WebCola</strong> â†’ The resulting <code>InstanceLayout</code> is passed into the <code>&lt;webcola-cnd-graph&gt;</code> custom element, which renders an SVG using WebCola. Changing the <em>Layout Format</em> dropdown re-renders with the same layout data.</li>
            <li><strong>Inspect + iterate</strong> â†’ The Evaluator REPL mount lets you probe relations from your evaluator, while the CND textarea reflects the active YAML. Edit either input, then rerun <strong>Apply Layout</strong> to verify the pipeline end-to-end.</li>
        </ol>
    </div>

    <!-- D3 v4 and WebCola - the working combination -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="../vendor/cola.js"></script>
    
    <!-- Complete CND-Core browser bundle -->
    <script src="../dist/browser/spytial-core-complete.global.js"></script>
    
    <!-- Your React component bundle (includes React runtime) -->
    <script src="../dist/components/react-component-integration.global.js"></script>
    <link rel="stylesheet" href="../dist/components/react-component-integration.css">
    <script>
        // Variables to store data
        let currentInstanceLayout = null;

        // Guided sample locations (used for onboarding)
        const SAMPLE_PATHS = {
            alloy: '../sample/forge/datum.xml',
            cnd: '../sample/forge/layout.cnd'
        };

        // Minimal fallbacks so the onboarding flow still works offline
        const SAMPLE_ALLOY_FALLBACK = '<alloy>\n  <instance><sig label="Node" ID="1" parentID="2"><atom label="Node0"/><atom label="Node1"/></sig></instance>\n</alloy>';
        const SAMPLE_CND_FALLBACK = `constraints:\n  - orientation:\n      selector: Node\n      directions:\n        - right`;        

        /**
         * Get current Alloy XML from input field
         * @returns {string} Alloy XML specification
         */
        function getCurrentAlloyXml() {
            return document.getElementById('webcola-alloy').value.trim();
        }

        /**
         * Get current CND specification from input field  
         * @returns {string} CND layout specification
         */
        function getCurrentCNDSpec() {
            // Try to get value from React component first
            return window.getCurrentCNDSpecFromReact ?
                window.getCurrentCNDSpecFromReact() :
                document.getElementById('webcola-cnd')?.value?.trim();
        }

        /**
         * Fetch helper for onboarding samples with graceful fallbacks
         * @param {string} url - relative path to sample asset
         * @param {string} fallback - fallback value if fetch fails
         * @returns {Promise<string>} resolved content
         */
        async function loadSampleText(url, fallback) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                console.warn(`Unable to fetch sample from ${url}:`, error);
                return fallback;
            }
        }

        /**
         * Sync YAML spec into the mounted CND interface (React + DOM fallback)
         * @param {string} yamlText - YAML specification
         */
        function syncCndSpecToInterface(yamlText) {
            const trimmedSpec = yamlText.trim();
            try {
                if (window.CndCore?.CndLayoutStateManager) {
                    const stateManager = window.CndCore.CndLayoutStateManager.getInstance();
                    stateManager.setYamlValue(trimmedSpec);
                }

                const reactTextarea = document.querySelector('#webcola-cnd-container textarea');
                if (reactTextarea instanceof HTMLTextAreaElement) {
                    reactTextarea.value = trimmedSpec;
                    reactTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                }
            } catch (error) {
                console.warn('Could not sync CND spec into the interface:', error);
            }
        }

        /**
         * Update status display with proper styling
         * @param {string} message - Status message to display
         * @param {string} type - Status type: 'info', 'success', 'error'
         */
        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        /**
         * Prefill the Alloy + CND inputs with the guided onboarding sample
         * @param {boolean} autoRender - when true, immediately runs the pipeline
         */
        async function loadGuidedSample(autoRender = false) {
            updateStatus('Loading guided sample...', 'info');

            const [alloyText, cndText] = await Promise.all([
                loadSampleText(SAMPLE_PATHS.alloy, SAMPLE_ALLOY_FALLBACK),
                loadSampleText(SAMPLE_PATHS.cnd, SAMPLE_CND_FALLBACK)
            ]);

            // Prefill the Alloy XML input
            document.getElementById('webcola-alloy').value = alloyText.trim();

            // Sync the CND YAML into the interface
            syncCndSpecToInterface(cndText);

            updateStatus('Guided sample loaded. Press Apply Layout to render.', 'success');

            if (autoRender) {
                await loadGraph();
            }
        }

        /**
         * Initialize the Alloy pipeline components
         * @returns {boolean} Success status
         */
        async function initializePipeline() {
            try {
                console.log('Complete CND-Core browser bundle loaded successfully');
                console.log('Available on global CndCore:', Object.keys(CndCore));
                
                // Check for Alloy-specific components
                console.log('parseAlloyXML available:', !!CndCore.AlloyInstance.parseAlloyXML);
                console.log('ForgeEvaluator available:', !!CndCore.ForgeEvaluator);
                console.log('LayoutInstance available:', !!CndCore.LayoutInstance);
                console.log('parseLayoutSpec available:', !!CndCore.parseLayoutSpec);
                
                updateStatus('Alloy pipeline ready! Enter Alloy XML and CND specifications now.', 'success');
                
                return true;
            } catch (error) {
                console.error('Failed to initialize Alloy pipeline:', error);
                updateStatus(`Pipeline init failed: ${error.message}`, 'error');
                return false;
            }
        }

        /**
         * Process Alloy data using the complete Alloy â†’ ForgeEvaluator â†’ Layout pipeline
         */
        async function loadAlloyData() {
            try {
                updateStatus('Processing Alloy data with ForgeEvaluator...', 'info');

                // Get Alloy XML from input field
                const alloyXml = getCurrentAlloyXml();
                if (!alloyXml) {
                    throw new Error('Please enter an Alloy XML instance')   ;
                }

                // Get CND specification from input field
                const cndSpec = getCurrentCNDSpec() || "";

                console.log('Using Alloy XML:', alloyXml.substring(0, 200) + '...');
                console.log('Using CND Spec:', cndSpec.substring(0, 200) + '...');

                // Step 1: Parse Alloy XML
                updateStatus('Parsing Alloy XML...', 'info');
                const alloyDatum = CndCore.AlloyInstance.parseAlloyXML(alloyXml);
                console.log('Parsed Alloy Datum:', alloyDatum);
                
                if (!alloyDatum.instances || alloyDatum.instances.length === 0) {
                    throw new Error('No instances found in Alloy XML');
                }

                const alloyDataInstance = new CndCore.AlloyDataInstance(alloyDatum.instances[0]);
                // Now we need to convert thi

                console.log('Using Alloy Data Instance:', alloyDataInstance);
                console.log('Types via Alloy IDataInstance:', alloyDataInstance.getTypes().length);
                console.log('Atoms via Alloy IDataInstance:', alloyDataInstance.getAtoms().length);
                console.log('Relations via Alloy IDataInstance:', alloyDataInstance.getRelations().length);

                // Step 2: Create ForgeEvaluator with Alloy data
                updateStatus('Creating ForgeEvaluator...', 'info');


                let evaluationContext = {
                    sourceData: alloyXml,
                }; //alloyDatum
                const forgeEvaluator = new CndCore.ForgeEvaluator();
                forgeEvaluator.initialize(evaluationContext);

                console.log('Created ForgeEvaluator:', forgeEvaluator);

                // NOTE: Mount Evaluator REPL
                if (window.mountEvaluatorRepl) {
                    window.mountEvaluatorRepl('evaluator-repl-mount', forgeEvaluator, 0);
                } else {
                    console.warn('Evaluator REPL mount function not available. Skipping REPL mount.');
                }

                // Step 3: Parse layout specification
                updateStatus('Parsing layout specification...', 'info');
                let layoutSpec = null;
                try {
                    layoutSpec = CndCore.parseLayoutSpec(cndSpec);
                    if (window.clearAllErrors) {
                        window.clearAllErrors();
                    }
                } catch (error) {
                    console.error('Layout spec parse error:', error);
                    if (window.showParseError) {
                        window.showParseError(error.message, 'Layout Specification');
                    } else {
                        updateStatus(`Layout spec parse error: ${error.message}`, 'error');
                    }
                    return;
                }
                console.log('Parsed Layout Spec:', layoutSpec);

                // Step 4: Create LayoutInstance with ForgeEvaluator
                updateStatus('Creating layout instance with ForgeEvaluator...', 'info');
                const ENABLE_ALIGNMENT_EDGES = true;
                const instanceNumber = 0;
                
                
                const layoutInstance = new CndCore.LayoutInstance(
                    layoutSpec, 
                    forgeEvaluator, 
                    instanceNumber, 
                    ENABLE_ALIGNMENT_EDGES
                );
                console.log('Created Layout Instance with ForgeEvaluator:', layoutInstance);

                // Step 5: Generate layout using Alloy data instance
                updateStatus('Generating layout with Alloy data...', 'info');
                const projections = {};

                try {
                    const layoutResult = layoutInstance.generateLayout(alloyDataInstance, projections);
                    currentInstanceLayout = layoutResult.layout;
    
                    if (layoutResult.error) {
                        console.error('Layout generation error:', layoutResult.error);
    
                        // Check if this is a constraint conflict error
                        if (layoutResult.error.errorMessages) {
                            if (window.showPositionalError) {
                                window.showPositionalError(layoutResult.error.errorMessages);
                            } else {
                                updateStatus(`Positional constraint conflict: ${layoutResult.error.message}`, 'error');
                            }
                        } else if (layoutResult.error.overlappingNodes) {
                            if (window.showGroupOverlapError) {
                                window.showGroupOverlapError(layoutResult.error.message);
                            } else {
                                updateStatus(`Group overlap error: ${layoutResult.error.message}`, 'error');
                            }
                        } else {
                            if (window.showGeneralError) {
                                window.showGeneralError(`Layout generation error: ${layoutResult.error.message}`);
                            } else {
                                updateStatus(`Layout generation error: ${layoutResult.error.message}`, 'error');
                            }
                        }

                        // Set the webcola-cnd-graph element to indicate unsat state
                        const webcolaGraphElement = document.getElementById('graph-container');
                        webcolaGraphElement.setAttribute('unsat', "");

                        return;
                    }
                } catch (error) {
                    if (window.showGeneralError) {
                        window.showGeneralError(`Layout generation failed: ${error.message}`);
                    } else {
                        updateStatus(`Layout generation failed: ${error.message}`, 'error');
                    }
                    return;
                }

                const webcolaGraphElement = document.getElementById('graph-container');
                webcolaGraphElement.removeAttribute('unsat'); // Clear unsat state

                // Clear errors on successful layout generation
                if (window.clearAllErrors) {
                    window.clearAllErrors();
                }

                console.log('Generated Instance Layout using Alloy pipeline:', currentInstanceLayout);

                updateStatus('Alloy pipeline complete with ForgeEvaluator! Ready to render.', 'success');
                
            } catch (error) {
                console.error('Failed to load Alloy data:', error);
                updateStatus(`Alloy data loading failed: ${error.message}`, 'error');
            }
        }

        /**
         * Render the graph using the webcola-cnd-graph custom element
         */
        async function renderGraph() {
            clearGraph(); // Clear existing graph first
            const graphElement = document.getElementById('graph-container');
            
            try {
                if (!currentInstanceLayout) {
                    updateStatus('No layout data available. Processing Alloy data first...', 'info');
                    await loadAlloyData();
                    if (!currentInstanceLayout) {
                        throw new Error('Failed to generate layout data from Alloy');
                    }
                }

                updateStatus('Rendering Alloy graph with WebCola...', 'info');
                
                // Use the real InstanceLayout data with WebCola custom element
                await graphElement.renderLayout(currentInstanceLayout);

                updateStatus('Alloy graph rendered successfully!', 'success');
            } catch (error) {
                console.error('Error rendering Alloy graph:', error);
                updateStatus(`Alloy render error: ${error.message}`, 'error');
            }
        }

        /**
         * Clear the graph and reset state
         */
        function clearGraph() {
            const graphElement = document.getElementById('graph-container');
            
            // Clear the graph
            if (graphElement.clear) {
                // FIXME: The graphElement needs a clear() method
                graphElement.clear();
            } else {
                // Fallback: remove all SVG content
                const svg = graphElement.shadowRoot?.querySelector('svg');
                if (svg) {
                    const container = svg.querySelector('.zoomable');
                    if (container) {
                        container.innerHTML = '';
                    }
                }
            }
            
            // Clear stored layout
            currentInstanceLayout = null;
            
            updateStatus('Graph cleared.', 'info');
        }

        /**
         * Load and render Alloy graph in one step
         */
        async function loadGraph() {
            try {
                await loadAlloyData();
                await renderGraph();
            } catch (error) {
                console.error('Failed to load and render Alloy graph:', error);
                updateStatus(`Failed to load Alloy graph: ${error.message}`, 'error');
            }
        }

        async function changeLayoutFormat() {
            const graphElement = document.getElementById('graph-container');
            const layoutFormat = document.getElementById('layoutFormat').value;
            graphElement.setAttribute('layoutFormat', layoutFormat);
            console.log(`Layout format changed to: ${layoutFormat}`);

            // Re-render the graph with the new layout format
            try {
                if (!currentInstanceLayout) {
                    throw new Error('No layout data available. Please load an Alloy graph first.');
                }
                await graphElement.renderLayout(currentInstanceLayout);
                updateStatus('Graph layout changed successfully!', 'success');
            } catch (error) {
                console.error('Error rendering graph:', error);
                updateStatus(`Render error: ${error.message}`, 'error');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Mouont the window.mountRelationHighlighter
            const graphElement = document.getElementById('graph-container');
            if (graphElement && window.mountRelationHighlighter) {
                window.mountRelationHighlighter('relation-highlighter-mount', 'graph-container');
            }
        });

        // Auto-initialize when page loads
        window.addEventListener('load', () => {
            initializePipeline();
            // Mount React component if available
            if (window.mountCndLayoutInterface) {
                window.mountCndLayoutInterface('webcola-cnd-container', {
                    initialYamlValue: SAMPLE_CND_FALLBACK
                });
            }

            // Mount error message system
            if (window.mountErrorMessageModal) {
                window.mountErrorMessageModal();
            }

            // Prefill onboarding sample content so newcomers can click-and-run
            loadGuidedSample(false);
        });

        // Expose functions globally for buttons
        window.loadGraph = loadGraph;
        window.loadAlloyData = loadAlloyData;
        window.renderGraph = renderGraph;
        window.clearGraph = clearGraph;
    </script>
</body>
</html>
